# Object-Oriented programming and C++

Our lives are the best example of adaptive thinking; we are procedure-oriented at times and object-oriented at other times.
For example, if I work at Google, I would say _"I am going to office"_ rather than _"I am going to Google"_. So, we have categorised Google as an Office in a blanket term since the emphasis is on _going to office_, and not on which office.

Who doesn't like pizza? When you desire pizza, you usually think of going to a pizza place nearby and ordering it, which is a procedural way of thinking. The emphasis is on the process - _'having a pizza'_.
When we intend to visit a Subway location, though, we are more objective. The plan is to eat whatever is available at Subway that meets our preferences and budget. So Subway has become the _objective_ of our eating/hunger needs.
We keep objectifying things. We don't wake up as an Engineer or something, we wake in real mode as a person, or a human being. We then objectify ourselves in order to get the work done -- in office hours we are engineers, at the pool table, we are pool players, etc.
Does that tell you have with the right context, we can change how we behave, or even change the core function we have? Indeed!

Speaking in programming paradigm, most of us have learnt C and/or assembly as the first programming language. That has helped us to develop an algorithmic thought-process, but at the same time it has always limited us think in a _procedural_ way.
A simple assembly program to add two numbers would be nothing but a procedure similar to this -- 
* Flush a register with 0 value to store the carry
* Load the two numbers in separate memory locations
* Load one of the two numbers in accumulator
* Load the other into a separate register
* Add the other register (holding second number) into the accumulator
* Jump if no carry, else increment the value at carry register 
* Fetch accumulator to move the result is a seperate memory location

Technicalities apart, we thought of this as a procedure. There is no _object_ involved in this.
Our adventures with the C programming language are similar, at least in the beginning. We didn't learn the concept of objects until we learnt about structure. 
We learnt adding two numbers using local variables, we didn't write functions for addition as the first-way of doing t, did we? Majority of C programming is still very procedure-oriented.

**The Object-Oriented way:**
We all have heard this term **_Object-Oriented Programming_**, and all the talk about the 4 pillars of it. For a beginner, it might appear that the whole programming is about following certain principles, which is not entirely true. It is worth noting that, everything in OOP seems to revolve around classes and objects, and one might err to think that objects are anyways instances of classes. So, why it isn't called **_Class-oriented programming_** instead? 
Answer to the question lays in the fundamentals aspects of how an object is used. 

# C++
These are C++ Programs developed during the knowledge-building of C++ programming. I understand that these codes in any form as of today are not suitable/worthy of using in any of the ongoing developments.
A huge segment of the write-ups are taken (at times, word by word) from many of the reference books that I have been going through such as C++ Prime Plus by Stephen Prata. I have been a huge admirer of his way of writing technical content and explaning concepts of programming in a manner more relatable to a engineer than a mere student. 
